<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adiar: Queens</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adiar
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
   <div id="projectbrief">An External Memory Decision Diagram Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('queens.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Queens </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md14">Computing the set of all solutions</a><ul><li class="level2"><a href="#autotoc_md15">Explicitly Constructing Base Cases</a></li>
<li class="level2"><a href="#autotoc_md16">Constructing the Entire Board</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md17">Counting the Number of Solutions</a></li>
<li class="level1"><a href="#autotoc_md18">Printing each Solution</a></li>
</ul>
</div>
<div class="textblock"><p>The N-Queens problem is the following combinatorial problem</p>
<blockquote class="doxtable">
<p>Given N, then in how many ways can N queens be placed on an N x N chess board without threatening each other? </p>
</blockquote>
<p>We will solve this problem using BDDs.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md14"></a>
Computing the set of all solutions</h1>
<p>We will compute the BDD containing all the solutions as described in the paper "Parallel Disk-Based Computation for Large, Monolithic Binary Decision Diagrams" by Daniel Kunkle, Vlad Slavici, and Gene Cooperman.</p>
<p>We need to first choose some encoding of the problem into a set of variables. We will stay with the simple row-by-row ordering of variables for now. That is, we represent whether a queen is placed at position (<em>i</em>,<em>j</em>) on the <em>N_Ã—_N</em> board board as the variable with label computed as follows.</p>
<div class="fragment"><div class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> <a class="code" href="classadiar_1_1internal_1_1dd.html#a2442a4edc93ba57f00ecb249dc766a34">adiar::bdd::label_t</a> label_of_position(uint64_t N, uint64_t i, uint64_t j)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> (N * i) + j;</div>
<div class="line">}</div>
<div class="ttc" id="aclassadiar_1_1internal_1_1dd_html_a2442a4edc93ba57f00ecb249dc766a34"><div class="ttname"><a href="classadiar_1_1internal_1_1dd.html#a2442a4edc93ba57f00ecb249dc766a34">adiar::internal::dd::label_t</a></div><div class="ttdeci">node_t::label_t label_t</div><div class="ttdoc">Type of this node's variable label.</div><div class="ttdef"><b>Definition:</b> dd.h:227</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
Explicitly Constructing Base Cases</h2>
<p>Let us first restrict our attention to the base case of expressing the state of a single field (<em>i</em>,<em>j</em>). We need to express that a single queen is placed here, and that this queen is in no conflict with any other placed on the board, i.e. any queens on the same row, column or diagonals. This essentially is the formula </p><p class="formulaDsp">
\[ x_{ij} \land \neg \mathit{is\_threatened}(i,j) \]
</p>
<p> where <em>is_threatened</em>(i,j) is true if one or more queens are placed on conflicting positions.</p>
<p>We could construct the BDD with the builders and algorithms of <em>Adiar</em>. But, we can do even better than that, because the resulting BDD is well structured. So, we can explicitly construct in one go with a <code><a class="el" href="group__module____builder.html#gacad7fc21ff3b724b2c485f4d9da5dc2f" title="Builder for BDDs.">adiar::bdd_builder</a></code>! Remember that nodes are to be constructed bottom-up. By the ordering of variables in <code>label_of_position</code> we have to deal with (1) queens on the row <em>i</em> and (2) queens on other rows. For (1) we have to check all variables, whereas for (2) we only need to check on column <em>j</em> and the diagonals. All nodes but the one for x<sub>ij</sub> are connected to by their <em>low</em> edge to the node generated before them (or to the <em>true</em> terminal if said node is first one generated). The x<sub>ij</sub> variable is, on the other hand, connected to the prior generated node by its high edge. All other edges go the to <em>false</em> terminal.</p>
<div class="fragment"><div class="line"><a class="code" href="classadiar_1_1bdd.html">adiar::bdd</a> n_queens_S(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classadiar_1_1builder.html">adiar::bdd_builder</a> builder;</div>
<div class="line"> </div>
<div class="line">  uint64_t row = N - 1;</div>
<div class="line">  <a class="code" href="classadiar_1_1builder__ptr.html">adiar::bdd_ptr</a> next = builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">do</span> {</div>
<div class="line">    uint64_t row_diff = std::max(row,i) - std::min(row,i);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (row_diff == 0) {</div>
<div class="line">      <span class="comment">// On row of the queen in question</span></div>
<div class="line">      uint64_t column = N - 1;</div>
<div class="line">      <span class="keywordflow">do</span> {</div>
<div class="line">        <span class="keyword">typename</span> <a class="code" href="classadiar_1_1internal_1_1dd.html#a2442a4edc93ba57f00ecb249dc766a34">adiar::bdd::label_t</a> label = label_of_position(N, row, column);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If (row, column) == (i,j), then the chain goes through high</span></div>
<div class="line">        <span class="comment">// such we check the queen actually is placed here.</span></div>
<div class="line">        next = column == j</div>
<div class="line">          ? builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(label, <span class="keyword">false</span>, next)</div>
<div class="line">          : builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(label, next, <span class="keyword">false</span>);</div>
<div class="line">      } <span class="keywordflow">while</span> (column-- &gt; 0);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// On another row</span></div>
<div class="line">      <span class="keywordflow">if</span> (j + row_diff &lt; N) {</div>
<div class="line">        <span class="comment">// Diagonal to the right is within bounds</span></div>
<div class="line">        next = builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(label_of_position(N, row, j + row_diff),</div>
<div class="line">                                next,</div>
<div class="line">                                <span class="keyword">false</span>);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Column</span></div>
<div class="line">      next = builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(label_of_position(N, row, j), next, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span> (row_diff &lt;= j) {</div>
<div class="line">        <span class="comment">// Diagonal to the left is within bounds</span></div>
<div class="line">        next = builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(label_of_position(N, row, j - row_diff),</div>
<div class="line">                                next,</div>
<div class="line">                                <span class="keyword">false</span>);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  } <span class="keywordflow">while</span> (row-- &gt; 0);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classadiar_1_1bdd.html">adiar::bdd</a> res = builder.<a class="code" href="classadiar_1_1builder.html#ab01d6031368c51291ce565b03c049775">build</a>();</div>
<div class="line"> </div>
<div class="line">  largest_nodes = std::max(largest_nodes, <a class="code" href="group__module____bdd.html#ga1117a062b67bed809d230f6fac83f60a">bdd_nodecount</a>(res));</div>
<div class="line">  <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
<div class="ttc" id="aclassadiar_1_1bdd_html"><div class="ttname"><a href="classadiar_1_1bdd.html">adiar::bdd</a></div><div class="ttdoc">A reduced Binary Decision Diagram.</div><div class="ttdef"><b>Definition:</b> bdd.h:46</div></div>
<div class="ttc" id="aclassadiar_1_1builder__ptr_html"><div class="ttname"><a href="classadiar_1_1builder__ptr.html">adiar::builder_ptr</a></div><div class="ttdoc">The pointer type that builders use to identify the nodes they have constructed in a decision diagram.</div><div class="ttdef"><b>Definition:</b> builder.h:54</div></div>
<div class="ttc" id="aclassadiar_1_1builder_html"><div class="ttname"><a href="classadiar_1_1builder.html">adiar::builder</a></div><div class="ttdoc">A builder for decision diagrams.</div><div class="ttdef"><b>Definition:</b> builder.h:113</div></div>
<div class="ttc" id="aclassadiar_1_1builder_html_ab01d6031368c51291ce565b03c049775"><div class="ttname"><a href="classadiar_1_1builder.html#ab01d6031368c51291ce565b03c049775">adiar::builder::build</a></div><div class="ttdeci">dd_policy::reduced_t build()</div><div class="ttdoc">Builds the decision diagram with the added nodes. This also clears the builder.</div><div class="ttdef"><b>Definition:</b> builder.h:381</div></div>
<div class="ttc" id="aclassadiar_1_1builder_html_ab6a82eebf191476fa81afd686c2888cd"><div class="ttname"><a href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">adiar::builder::add_node</a></div><div class="ttdeci">builder_ptr&lt; dd_policy &gt; add_node(typename dd_policy::label_t label, const builder_ptr&lt; dd_policy &gt; &amp;low, const builder_ptr&lt; dd_policy &gt; &amp;high)</div><div class="ttdoc">Add an internal node with a given label and its two children.</div><div class="ttdef"><b>Definition:</b> builder.h:201</div></div>
<div class="ttc" id="agroup__module____bdd_html_ga1117a062b67bed809d230f6fac83f60a"><div class="ttname"><a href="group__module____bdd.html#ga1117a062b67bed809d230f6fac83f60a">adiar::bdd_nodecount</a></div><div class="ttdeci">size_t bdd_nodecount(const bdd &amp;f)</div><div class="ttdoc">The number of (internal) nodes used to represent the function.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md16"></a>
Constructing the Entire Board</h2>
<p>From the formula in <code>n_queens_S</code> we can construct the formula for the entire row by combining them with an OR. Since the formula is <em>true</em> only when the queen is placed then this ensures at-least-one queen is placed on the row. Since <code>n_queens_S</code> is also only <em>true</em> when said queen has no conflicts then this also immediately contains the at-most-one queen constraint for said row.</p>
<div class="fragment"><div class="line"><a class="code" href="classadiar_1_1bdd.html">adiar::bdd</a> n_queens_R(<span class="keywordtype">int</span> N, <span class="keywordtype">int</span> row)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classadiar_1_1bdd.html">adiar::bdd</a> out = n_queens_S(N, row, 0);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 1; j &lt; N; j++) {</div>
<div class="line">    out |= n_queens_S(N, row, j);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now that we can represent a single row, then we only need to combine them such that all rows are satisfied at the same time. That is, we need to combine the BDDs constructed in <code>n_queens_R</code> with an AND.</p>
<div class="fragment"><div class="line"><a class="code" href="classadiar_1_1bdd.html">adiar::bdd</a> n_queens_B(<span class="keywordtype">int</span> N)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (N == 1) { <span class="keywordflow">return</span> n_queens_S(N, 0, 0); }</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classadiar_1_1bdd.html">adiar::bdd</a> out = n_queens_R(N, 0);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; N; i++) {</div>
<div class="line">    out &amp;= n_queens_R(N, i);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md17"></a>
Counting the Number of Solutions</h1>
<p>When the entire board is constructed as described above, then we merely need to count the number of satisfying solutions to the generated BDD.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  uint64_t N = std::stoi(argv[1])</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classadiar_1_1bdd.html">adiar::bdd</a> board = n_queens_B(N);</div>
<div class="line">  std::cout &lt;&lt; <a class="code" href="group__module____bdd.html#ga2bf2d6300652daee73000c379e0b182e">bdd_satcount</a>(board) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__module____bdd_html_ga2bf2d6300652daee73000c379e0b182e"><div class="ttname"><a href="group__module____bdd.html#ga2bf2d6300652daee73000c379e0b182e">adiar::bdd_satcount</a></div><div class="ttdeci">uint64_t bdd_satcount(const bdd &amp;f, bdd::label_t varcount)</div><div class="ttdoc">Count the number of assignments x that make f(x) true.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md18"></a>
Printing each Solution</h1>
<p>The following is based on a <a href="github.com/MartinFaartoft/n-queens-bdd/blob/master/report.tex">report by Martin Faartoft</a>.</p>
<p>If we want to list all the assignments then we have to do something more than merely count the number of satisfying assignments. But, given the BDD we just constructed we can use it to prune our search tree for valid assignments.</p>
<p>Starting at the left-most column we will attempt to place a queen in one of the rows by <em>restricting</em> the assignment to the variables in question. For each attempt we will recurse to the next column. Recursion can be stopped early in two cases:</p>
<ul>
<li>If the given BDD already is trivially false then we have placed a queen, such that it conflicts with another.</li>
<li>If the number of unique paths in the restricted BDD is exactly one, then we are forced to place the remaining queens.</li>
</ul>
<p>Since we want to backtrack our choices, we may keep BDDs for each column. This naturally happens by writing it as a recursive procedure. One should notice though, that this will result in multiple BDDs concurrently being instantiated in memory and on disk.</p>
<p>We first need to convert a label back into a position on the board before getting to that . So, we'll also need the following two small functions.</p>
<div class="fragment"><div class="line"><span class="keyword">inline</span> uint64_t i_of_label(uint64_t N, <span class="keyword">typename</span> <a class="code" href="classadiar_1_1internal_1_1dd.html#a2442a4edc93ba57f00ecb249dc766a34">adiar::bdd::label_t</a> label)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> label / N;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> uint64_t j_of_label(uint64_t N, <span class="keyword">typename</span> <a class="code" href="classadiar_1_1internal_1_1dd.html#a2442a4edc93ba57f00ecb249dc766a34">adiar::bdd::label_t</a> label)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> label % N;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now we are ready to implement the recursive procedure that takes care of a row and possibly recurses. For a sanity check, we also return the number of solutions we have listed.</p>
<div class="fragment"><div class="line">uint64_t n_queens_list(uint64_t N, uint64_t column,</div>
<div class="line">                       std::vector&lt;uint64_t&gt;&amp; partial_assignment,</div>
<div class="line">                       <span class="keyword">const</span> bdd&amp; constraints)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="group__module____bdd.html#ga0e5de81efc49b8e0aaa137013e2422c1">is_terminal</a>(constraints, <a class="code" href="group__module____bdd.html#gaa770b1d0ae408db9345b064a4dd8390d">is_false</a>)) {</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">  }</div>
<div class="line">  uint64_t solutions = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (uint64_t row_q = 0; row_q &lt; N; row_q++) {</div>
<div class="line">    partial_assignment.push_back(row_q);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Construct the assignment for this entire column</span></div>
<div class="line">    adiar::assignment_file column_assignment;</div>
<div class="line"> </div>
<div class="line">    { <span class="comment">// The assignment_writer has to be detached, before we call any</span></div>
<div class="line">      <span class="comment">// bdd functions. It is automatically detached upon destruction,</span></div>
<div class="line">      <span class="comment">//  hence we have it in this little scope.</span></div>
<div class="line">      <a class="code" href="namespaceadiar.html#ac0c8a98240760bd6186b1f3f590abca8">adiar::file_writer&lt;map_pair&lt;bdd::label_t, bool&gt;</a>&gt; aw(column_assignment);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (uint64_t row = 0; row &lt; N; row++) {</div>
<div class="line">        aw &lt;&lt; <a class="code" href="namespaceadiar.html#a723cfcc9239dfdc3cf4cdc74df0265c2">assignment</a>(label_of_position(N, row, column),</div>
<div class="line">                                row == row_q);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classadiar_1_1bdd.html">adiar::bdd</a> restricted_constraints = <a class="code" href="group__module____bdd.html#gadb286670a1afdfac65d51777e9f4346e">adiar::bdd_restrict</a>(constraints,</div>
<div class="line">                                                            column_assignment);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__module____bdd.html#gadd0becff66aaae9313c29248bc33750e">adiar::bdd_pathcount</a>(restricted_constraints) == 1) {</div>
<div class="line">      solutions += 1;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Add dummys in &#39;partial_assignment&#39;</span></div>
<div class="line">      <span class="keywordflow">while</span> (partial_assignment.size() &lt; N) {</div>
<div class="line">        partial_assignment.push_back(-1);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Obtain the lexicographically minimal true assignment. Well, only one</span></div>
<div class="line">      <span class="comment">// exists, so we get the only one left.</span></div>
<div class="line">      <a class="code" href="group__module____bdd.html#ga82d50901064486da23984c7dfac196c0">adiar::bdd_satmin</a>(restricted_constraints, [&amp;N, &amp;partial_assignment](<a class="code" href="classadiar_1_1internal_1_1dd.html#a2442a4edc93ba57f00ecb249dc766a34">adiar::bdd::label_t</a> x, <span class="keywordtype">bool</span> v) {</div>
<div class="line">        <span class="comment">// Skip all empty (false) locations</span></div>
<div class="line">        <span class="keywordflow">if</span> (!v) { <span class="keywordflow">return</span>; }</div>
<div class="line"> </div>
<div class="line">        partial_assignment.at(j_of_label(N, x)) = i_of_label(N, x);</div>
<div class="line">      });</div>
<div class="line"> </div>
<div class="line">      n_queens_print_solution(partial_assignment);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (uint64_t c = N-1; c &gt; column; c--) {</div>
<div class="line">        partial_assignment.pop_back();</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="group__module____bdd.html#ga0e5de81efc49b8e0aaa137013e2422c1">is_terminal</a>(restricted_constraints, <a class="code" href="group__module____bdd.html#ga669be328589daa02ac9e609610ce64a1">is_true</a>)) {</div>
<div class="line">      n_queens_print_solution(partial_assignment);</div>
<div class="line">      solutions += 1;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      solutions += n_queens_list(N,</div>
<div class="line">                                 column+1,</div>
<div class="line">                                 partial_assignment,</div>
<div class="line">                                 restricted_constraints);</div>
<div class="line">    }</div>
<div class="line">    partial_assignment.pop_back();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> solutions;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">uint64_t n_queens_list(uint64_t N, <span class="keyword">const</span> <a class="code" href="classadiar_1_1bdd.html">adiar::bdd</a>&amp; board)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (N == 1) {</div>
<div class="line">    <span class="comment">// To make the recursive function work for N = 1 we would have to</span></div>
<div class="line">    <span class="comment">// have the count_paths above check at the beginning. That would</span></div>
<div class="line">    <span class="comment">// in all other cases merely result in an unecessary counting of</span></div>
<div class="line">    <span class="comment">// paths at the very start.</span></div>
<div class="line">    std::vector&lt;uint64_t&gt; <a class="code" href="namespaceadiar.html#a723cfcc9239dfdc3cf4cdc74df0265c2">assignment</a> { 0 };</div>
<div class="line">    n_queens_print_solution(assignment);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;uint64_t&gt; partial_assignment { };</div>
<div class="line">  partial_assignment.reserve(N);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> n_queens_list(N, 0, partial_assignment, board);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__module____bdd_html_ga0e5de81efc49b8e0aaa137013e2422c1"><div class="ttname"><a href="group__module____bdd.html#ga0e5de81efc49b8e0aaa137013e2422c1">adiar::is_terminal</a></div><div class="ttdeci">bool is_terminal(const bdd &amp;f)</div><div class="ttdoc">Whether this BDD represents a terminal.</div><div class="ttdef"><b>Definition:</b> bdd.h:601</div></div>
<div class="ttc" id="agroup__module____bdd_html_ga669be328589daa02ac9e609610ce64a1"><div class="ttname"><a href="group__module____bdd.html#ga669be328589daa02ac9e609610ce64a1">adiar::is_true</a></div><div class="ttdeci">bool is_true(const bdd &amp;f)</div><div class="ttdoc">Whether this BDD represents true terminal.</div><div class="ttdef"><b>Definition:</b> bdd.h:613</div></div>
<div class="ttc" id="agroup__module____bdd_html_ga82d50901064486da23984c7dfac196c0"><div class="ttname"><a href="group__module____bdd.html#ga82d50901064486da23984c7dfac196c0">adiar::bdd_satmin</a></div><div class="ttdeci">bdd bdd_satmin(const bdd &amp;f)</div><div class="ttdoc">The lexicographically smallest x such that f(x) is true.</div></div>
<div class="ttc" id="agroup__module____bdd_html_gaa770b1d0ae408db9345b064a4dd8390d"><div class="ttname"><a href="group__module____bdd.html#gaa770b1d0ae408db9345b064a4dd8390d">adiar::is_false</a></div><div class="ttdeci">bool is_false(const bdd &amp;f)</div><div class="ttdoc">Whether this BDD represents false terminal.</div><div class="ttdef"><b>Definition:</b> bdd.h:607</div></div>
<div class="ttc" id="agroup__module____bdd_html_gadb286670a1afdfac65d51777e9f4346e"><div class="ttname"><a href="group__module____bdd.html#gadb286670a1afdfac65d51777e9f4346e">adiar::bdd_restrict</a></div><div class="ttdeci">__bdd bdd_restrict(const bdd &amp;f, const shared_file&lt; map_pair&lt; bdd::label_t, assignment &gt;&gt; &amp;xs)</div><div class="ttdoc">Restrict a subset of variables to constant values.</div></div>
<div class="ttc" id="agroup__module____bdd_html_gadd0becff66aaae9313c29248bc33750e"><div class="ttname"><a href="group__module____bdd.html#gadd0becff66aaae9313c29248bc33750e">adiar::bdd_pathcount</a></div><div class="ttdeci">uint64_t bdd_pathcount(const bdd &amp;f)</div><div class="ttdoc">Count all unique (but not necessarily disjoint) paths to the true terminal.</div></div>
<div class="ttc" id="anamespaceadiar_html_a723cfcc9239dfdc3cf4cdc74df0265c2"><div class="ttname"><a href="namespaceadiar.html#a723cfcc9239dfdc3cf4cdc74df0265c2">adiar::assignment</a></div><div class="ttdeci">assignment</div><div class="ttdoc">Possible values to assign a variable.</div><div class="ttdef"><b>Definition:</b> assignment.h:13</div></div>
<div class="ttc" id="anamespaceadiar_html_ac0c8a98240760bd6186b1f3f590abca8"><div class="ttname"><a href="namespaceadiar.html#ac0c8a98240760bd6186b1f3f590abca8">adiar::file_writer</a></div><div class="ttdeci">internal::file_writer&lt; elem_t &gt; file_writer</div><div class="ttdef"><b>Definition:</b> file.h:25</div></div>
</div><!-- fragment --><p>where <code>n_queens_print_solutions</code> is a function that prints out the assignment file.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> n_queens_print_solution(std::vector&lt;uint64_t&gt;&amp; assignment)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">for</span> (uint64_t r : assignment) {</div>
<div class="line">    std::cout &lt;&lt; r &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Finally we can print all solutions by calling <code>n_queens_list</code> with the board constructed in <code>n_queens_B</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  uint64_t N = std::stoi(argv[1])</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classadiar_1_1bdd.html">adiar::bdd</a> board = n_queens_B(N);</div>
<div class="line">  n_queens_list(board);</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="page__examples.html">Examples</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
