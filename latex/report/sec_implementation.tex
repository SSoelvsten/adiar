% ---------------------------------------------------------------------------- %
% THE ALGORITHM IN PRACTICE
% ---------------------------------------------------------------------------- %
\section{A Cache-oblivious OBDD implementation} \label{sec:implementation}


\subsection{Representation of nodes} \label{sec:implementation__representation}
Inspired by \cite{Dijk16} we represent the \lstinline{NodeArc} type of
Code~\ref{lst:data} as a single 64-bit integer as shown in
Figure~\ref{fig:data}. A \lstinline{NodeArc.Sink} of value $v \in \{0,1\}$ is
represented by a $1$-flag on the most significant bit, $v$ on the least
significant bit, and all other bits set to $0$.\footnote{Notice, that we as such
  leave room for sinks taking on non-boolean values of up to $2^{63}$ bits.} A
\lstinline{NodeArc.Link} has a $0$-flag on the most significant bit, the next
$21$-bits dedicated to the \lstinline{label}, and finally the $42$ least
significant bits to contain the \lstinline{value}. This supports an OBDD of up
to $2^{21} \approx 2 \cdot 10^7$ variables and of size up to $2^{42} \approx
4.45 \cdot 10^{12}$ nodes.

\todo[inline]{Intermediate results may be larger than $10^{12}$ nodes. This can
  stay within this setup by resetting the ``index'' for each layer. This
  preserves the ordering.}

\begin{figure}[ht!]
  \centering

  \begin{subfigure}{0.49\linewidth}
    \centering \input{../tikz/data_sink.tex}
    \caption{\lstinline{NodeArc.Sink\{value: v\}} where \lstinline{v} $\in
      \{0,1\}$}
    \label{fig:data_sink}
  \end{subfigure}
  \begin{subfigure}{0.49\linewidth}
    \centering \input{../tikz/data_link.tex}
    \caption{\lstinline{NodeArc.Link\{label, index\}}}
    \label{fig:data_link}
  \end{subfigure}

  \caption{Visual representation of data layout. The least significant bit is
    right-most.}
  \label{fig:data}
\end{figure}

A \lstinline{Node} can then be represented by $3$ $64$-bit numbers: Two $64$-bit
integers for each child and another $64$ bits for the \lstinline{label} and
\lstinline{index} of the node itself with the same layout as for
\lstinline{NodeArc.Link}.

One should notice, that the sorting in the previous section with this layout is
a trivial sorting on $64$-bit numbers. In the case of the bottom-up \Reduce\
algorithm, the sorting is in descending order, while the top-down algorithms
\Restrict, \Apply, and \Equal\ use a sorting in ascending order. The sorting of
tuples $(t_1,t_2)$ in \Apply\ and \Equal\ is then a simple sorting of the 64-bit
numbers $\min(t_1,t_2)$ when \lstinline{data} is not present. Since
\lstinline{data} only is present for nodes with the same \lstinline{label}, then
the number to sort by simply becomes $\max(t_1,t_2)$ in that case. This
immediately extends to the later multi-sweep algorithms.


\subsection{Benchmark Results} \label{sec:implementation__benchmarks}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
