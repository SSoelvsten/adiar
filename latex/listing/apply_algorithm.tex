\begin{blstlisting}
  Apply(G$_1$ : Node[], G$_2$ : Node[], op: bool$\times$bool ->    bool):
    $\ReduceLwork, \ReduceLdep$ := [] : Node[] | (Node$\times$NodeArc$\times$bool)[]
    $\ApplyQrec$ := $\emptyset$ : PriorityQueue<...>

    iW$_1$ := G$_1$.length - 1; v$_1$ := G$_1$.V[iW$_1$]
    iW$_2$ := G$_2$.length - 1; v$_2$ := G$_2$.V[iW$_2$]

    // Process root and create initial recursion requests
    (root', low', high') := apply_root(v$_1$, v$_2$)

    $\ApplyQrec$.insert( (root', low', False, None)
                , (root', high', True, None))
    iO := -1

    // Process all nodes in topological order of both OBBDs
    v$_1$ := G$_1$.V[--iW$_1$]; v$_2$ := G$_2$.V[--iW$_2$]

    while iW$_1$ $\geq$ 0 or iW$_2$ $\geq$ 0:
      (s', (t$_1$, t$_1$), b, data) := $\ApplyQrec$.extract_min()

      // Forward if none match request; mutates *@\color{gray} $v_1, v_2, \mathit{iW}_1,$ and $\mathit{iW}_2$.@*
      while v$_1$ <>  t$_1$ $\land$ v$_2$ <>   t$_2$: apply_step()

      // Forward information across the layer?
      if t$_1$.label = t$_2$.label $\land$ ((v$_1$ <>    t$_1$ $\lor$ v$_2$ <>   t$_2$) $\land$ data = None):
        v$_o$ :=  if v$_1$ = t$_1$ then v$_1$ else v$_2$
        $\ApplyQrec$.insert( (s', (t$_1$, t$_1$), b, Some(v$_o$)) )
        while !$\ApplyQrec$.empty() $\land$ $\ApplyQrec$.peek_min()[1] = (t$_1$,t$_2$):
          (s', _, b, _) := $\ApplyQrec$.extract_min()
          $\ApplyQrec$.insert( (s', (t$_1$, t$_2$), b, Some(v$_o$)) )
        continue

      // Resolve current node and recurse
      (v', low', high') := apply_node((v$_1$,v$_2$), (t$_1$,t$_2$), data, iO--, op)
      
      if is_sink(low'):
        $\ReduceQdep$.insert(Edge{ source=v', is_high=False, target=low' })
      else:
        $\ApplyQrec$.insert( (v', low', False, None) )

      if is_sink(high'):
        $\ReduceQdep$.insert(Edge{ source=v', is_high=True, target=high' })
      else:
        $\ApplyQrec$.insert( (v', high', True, None) )

      while True:
        $\ReduceLforward$.append(Edge{ source=s', is_high=bool, target=v'})
        if !$\ApplyQrec$.empty() $\land$ $\ApplyQrec$.peek_min()[1] = (t$_1$,t$_2$):
          (s', (t$_1$,t$_1$), b, data) := $\ApplyQrec$.extract_min()
        else: break

    return Reduce($\ReduceLforward, \ReduceQdep$)
\end{blstlisting}
