\begin{blstlisting}
  Reduce($\ReduceLforward$: Edge[], $\ReduceQdep$: PriorityQueue<Edge>): Node[]
    indexO = 0; idO = MAX    // Index and id of next output
    iF := $\ReduceLforward$.length - 1         // Index into *@\color{cGray} $\ReduceLforward$@*

    // Process bottom-up each layer
    for j := n-1 downto 1:
      // No nodes left to process or no nodes with this label?
      if $\ReduceQdep$.empty() $\lor$ $\ReduceQdep$.peek().label <> j:
        continue

      $L_{j}$ := []

      // Merge nodes of layer j with result of prior computations
      while $\ReduceQdep$.peek().source.label = j:
        e_low  := $\ReduceQdep$.extract_max()
        e_high := $\ReduceQdep$.extract_max()

        $L_{j}$.append(node_of_edges(e_low, e_high))

      // Apply reduction rules
      ($L_{j,\mathit{out}}$, $L_{j,\mathit{red:}1}$, $L_{j,\mathit{red:}2}$) = reduce_layer($L_{j}$)

      // Add index and id to output and its related reduced nodes
      //   Notice, to-be outputted nodes in $\color{cGray}L_{j,\mathit{out}}$ and rule-2-reduced
      //   nodes in $\color{cGray}L_{j,\mathit{red:}2}$ are still sorted by their children.
      iR2 = 0
      for (w,w') in $L_{j,\mathit{out}}$:
        w'.index := indexO++; w'.id := idO--
        output w'

        while iR2 < $L_{j,\mathit{red:}2}$.length $\land$ $L_{j,\mathit{red:}2}$[iR2].low = w'.low
                                 $\land$ $L_{j,\mathit{red:}2}$[iR2].high = w'.high
          $L_{j,\mathit{red:}2}$[iR2++][1].index := w'.index

      // Forward processing information to layers j-1 .. 1
      $L_{j:F}$ := $L_{j,\mathit{out}}$ ++ $L_{j,\mathit{red:}1}$ ++ $L_{j,\mathit{red:}2}$

      Edge{ source, is_high, target } := $\ReduceLforward$[iF]
      for (w,w') in $L_{j:F}$ sorted by w.index:
        while target = w:
          $\ReduceQdep$.insert({
            source: source,
            is_high: is_high,
            target: nodearc_of_node(w') })
          Edge{ source, is_high, target } := $\ReduceLforward$[--iF]
\end{blstlisting}
