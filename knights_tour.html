<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adiar: Knight&#39;s Tour</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adiar
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
   <div id="projectbrief">An External Memory Decision Diagram Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('knights_tour.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Knight's Tour </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md8">Manual Construction of Constraints</a><ul><li class="level2"><a href="#autotoc_md9">Closed Tour</a></li>
<li class="level2"><a href="#autotoc_md10">Transition Function</a></li>
<li class="level2"><a href="#autotoc_md11">Hamiltonian Constraint</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md12">Combining Constraints</a></li>
<li class="level1"><a href="#autotoc_md13">Counting the Number of Paths</a></li>
</ul>
</div>
<div class="textblock"><p>The Knight's Tour problem is the following combinatorial problem</p>
<blockquote class="doxtable">
<p>Given N, then how many hamiltonian paths exist for a Knight (starting at any position) on an N x N chess board? </p>
</blockquote>
<p>The <em>closed</em> variant of this is for a <em>hamiltonian cycle</em>. We are going to use an N<sup>4</sup> encoding of which only N<sup>2</sup> positions are part of every final solution. Since this is very sparse, then we will solve this problem using ZDDs.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md8"></a>
Manual Construction of Constraints</h1>
<p>Our encoding is based off of the solution by Randal Bryant <a href="https://github.com/rebryant/Cloud-BDD/blob/conjunction_streamlined/hamiltonian/hpath.py">here</a>. To get around the entire board, the Knight will need to use N<sup>2</sup> time-steps. Our variable ordering will represent every <em>time-slice</em> together, where the board of each slice is similar to the <a class="el" href="queens.html">Queens</a> example. </p><div class="fragment"><div class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> <a class="code" href="classadiar_1_1internal_1_1dd.html#acf51971b31ef654d9a89b6828f1c3e5d">adiar::zdd::label_t</a> int_of_position(<span class="keywordtype">int</span> N, <span class="keywordtype">int</span> r, <span class="keywordtype">int</span> c, <span class="keywordtype">int</span> t = 0)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> (N * N * t) + (N * r) + c;</div>
<div class="line">}</div>
<div class="ttc" id="aclassadiar_1_1internal_1_1dd_html_acf51971b31ef654d9a89b6828f1c3e5d"><div class="ttname"><a href="classadiar_1_1internal_1_1dd.html#acf51971b31ef654d9a89b6828f1c3e5d">adiar::internal::dd::label_t</a></div><div class="ttdeci">node_t::label_t label_t</div><div class="ttdoc">Type of this node's variable label.</div><div class="ttdef"><b>Definition:</b> dd.h:137</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9"></a>
Closed Tour</h2>
<p>To only consider closed tours, i.e. hamiltonian cycles, we merely fix it to start in the top-left corner. Since we are counting <em>unoriented</em> paths, i.e. where the going backwards is not counted as another path, then we can also fix the next square at time step \( t=1 \) and the last one at \( t=N^2-1 \). The following code recognises whether a coordinate <em>i</em> and <em>j</em> is one of these squares.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> closed_squares [3][2] = { {0,0}, {1,2}, {2,1} };</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> is_closed_square(<span class="keywordtype">int</span> r, <span class="keywordtype">int</span> c)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> (r == closed_squares[0][0] &amp;&amp; c == closed_squares[0][1])</div>
<div class="line">      || (r == closed_squares[1][0] &amp;&amp; c == closed_squares[1][1])</div>
<div class="line">      || (r == closed_squares[2][0] &amp;&amp; c == closed_squares[2][1]);</div>
<div class="line">}</div>
</div><!-- fragment --><p>To encode the closed tours, we may force the Knight to start in the top-left corner and take one of the two solutions. By multiplying with a constant factor, we can then take the mirrored path and all possible starting positions into account.</p>
<p>So we need to encode that the Knight at time step \( t=0 \) is at position (0,0), at \( t=1 \) at (1,2), and at time step \( t=N^2-1 \) at (2,1). This is easy in ZDDs, since this is equivalent to skipping variables at these three time steps, such that only the "desired" positions are present and forced to true.</p>
<p>All remaining time steps remains one long "don't care" chain in between. Yet, inside of this chain we can encode the hamiltonian constraint for these three cells on the board by skipping them within the chain.</p>
<p>Hence, we can create the ZDD by hand using the <code><a class="el" href="group__module____builder.html#ga592e87250f7f8446244b8de707a0c5ec" title="Builder for ZDDs.">adiar::zdd_builder</a></code> as follows.</p>
<div class="fragment"><div class="line"><a class="code" href="classadiar_1_1zdd.html">adiar::zdd</a> constraint_closed(<span class="keywordtype">int</span> N)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classadiar_1_1builder.html">adiar::zdd_builder</a> builder;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Fix t = max_time to be (1,2)</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> max_time = N*N-1;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> stepMax_position = int_of_position(N,</div>
<div class="line">                                               closed_squares[2][0],</div>
<div class="line">                                               closed_squares[2][1],</div>
<div class="line">                                               max_time);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typename</span> <a class="code" href="classadiar_1_1builder__ptr.html">adiar::zdd_ptr</a> root = builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(stepMax_position, <span class="keyword">false</span>, <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// All in between is as-is but take the hamiltonian constraint into account.</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> t = max_time - 1; t &gt; 1; t--) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = N-1; r &gt;= 0; r--) {</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = N-1; c &gt;= 0; c--) {</div>
<div class="line">        <span class="keywordflow">if</span> (is_closed_square(r,c)) { <span class="keywordflow">continue</span>; }</div>
<div class="line"> </div>
<div class="line">        root = builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(int_of_position(N,r,c,t), root, root);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Fix t = 1 to be (2,1)</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> step1_position = int_of_position(N,</div>
<div class="line">                                             closed_squares[1][0],</div>
<div class="line">                                             closed_squares[1][1],</div>
<div class="line">                                             1);</div>
<div class="line">  root = builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(step1_position, <span class="keyword">false</span>, root);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Fix t = 0 to be (0,0)</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> step0_position = int_of_position(N,</div>
<div class="line">                                             closed_squares[0][0],</div>
<div class="line">                                             closed_squares[0][1],</div>
<div class="line">                                             0);</div>
<div class="line">  root = builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(step0_position, <span class="keyword">false</span>, root);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Finalize</span></div>
<div class="line">  <span class="keywordflow">return</span> builder.<a class="code" href="classadiar_1_1builder.html#ab01d6031368c51291ce565b03c049775">build</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclassadiar_1_1builder__ptr_html"><div class="ttname"><a href="classadiar_1_1builder__ptr.html">adiar::builder_ptr</a></div><div class="ttdoc">The pointer type that builders use to identify the nodes they have constructed in a decision diagram.</div><div class="ttdef"><b>Definition:</b> builder.h:53</div></div>
<div class="ttc" id="aclassadiar_1_1builder_html"><div class="ttname"><a href="classadiar_1_1builder.html">adiar::builder</a></div><div class="ttdoc">A builder for decision diagrams.</div><div class="ttdef"><b>Definition:</b> builder.h:112</div></div>
<div class="ttc" id="aclassadiar_1_1builder_html_ab01d6031368c51291ce565b03c049775"><div class="ttname"><a href="classadiar_1_1builder.html#ab01d6031368c51291ce565b03c049775">adiar::builder::build</a></div><div class="ttdeci">dd_policy::reduced_t build()</div><div class="ttdoc">Builds the decision diagram with the added nodes. This also clears the builder.</div><div class="ttdef"><b>Definition:</b> builder.h:379</div></div>
<div class="ttc" id="aclassadiar_1_1builder_html_ab6a82eebf191476fa81afd686c2888cd"><div class="ttname"><a href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">adiar::builder::add_node</a></div><div class="ttdeci">builder_ptr&lt; dd_policy &gt; add_node(typename dd_policy::label_t label, const builder_ptr&lt; dd_policy &gt; &amp;low, const builder_ptr&lt; dd_policy &gt; &amp;high)</div><div class="ttdoc">Add an internal node with a given label, id, and its two children.</div><div class="ttdef"><b>Definition:</b> builder.h:199</div></div>
<div class="ttc" id="aclassadiar_1_1zdd_html"><div class="ttname"><a href="classadiar_1_1zdd.html">adiar::zdd</a></div><div class="ttdoc">Reduced Ordered Zero-suppressed Decision Diagram.</div><div class="ttdef"><b>Definition:</b> zdd.h:49</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10"></a>
Transition Function</h2>
<p>Before tackling the construction of the ZDD for the transition function, let us first look at a single move. Since the main bottleneck is computing the ZDD operations, then the following computations will not necessarily be heavily optimised.</p>
<p>A Knight moves in an <em>L</em>-shape across the board, and so the following piece of code computes whether two coordinates represent a legal move.</p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> row_moves[8]    = { -2, -2, -1, -1,  1,  1,  2,  2 };</div>
<div class="line">constexpr <span class="keywordtype">int</span> column_moves[8] = { -1,  1, -2,  2, -2,  2, -1,  1 };</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> is_legal_move(<span class="keywordtype">int</span> <span class="comment">/*N*/</span>, <span class="keywordtype">int</span> r_from, <span class="keywordtype">int</span> c_from, <span class="keywordtype">int</span> r_to, <span class="keywordtype">int</span> c_to)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idx = 0; idx &lt; 8; idx++) {</div>
<div class="line">    <span class="keywordflow">if</span> (r_from + row_moves[idx] == r_to &amp;&amp;</div>
<div class="line">        c_from + column_moves[idx] == c_to) {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This can be extended to whether any position even is reachable.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> is_legal_position(<span class="keywordtype">int</span> N, <span class="keywordtype">int</span> r, <span class="keywordtype">int</span> c, <span class="keywordtype">int</span> t = 0)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (r &lt; 0 || N-1 &lt; r)  { <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div>
<div class="line">  <span class="keywordflow">if</span> (c &lt; 0 || N-1 &lt; c)  { <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div>
<div class="line">  <span class="keywordflow">if</span> (t &lt; 0 || N*N-1 &lt; t) { <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> is_reachable(<span class="keywordtype">int</span> <span class="comment">/*N*/</span>, <span class="keywordtype">int</span> r, <span class="keywordtype">int</span> c)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idx = 0; idx &lt; 8; idx++) {</div>
<div class="line">    <span class="keywordflow">if</span> (is_legal_position(N, r + row_moves[idx], c + column_moves[idx])) {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The transition function only encodes the time step <em>t</em> to <em>t+1</em>. That is, it needs to allow anything to happen at all other time steps. Hence, it also needs a somewhat similar "don't care" chain as the one for the closed constraint.</p>
<p>Combining everything above, we can create the transition function as follows.</p>
<div class="fragment"><div class="line"><a class="code" href="classadiar_1_1zdd.html">adiar::zdd</a> constraint_transition(<span class="keywordtype">int</span> N, <span class="keywordtype">int</span> t)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classadiar_1_1builder.html">adiar::zdd_builder</a> builder;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> max_cell = N-1;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Time steps t&#39; &gt; t+1:</span></div>
<div class="line">  <a class="code" href="classadiar_1_1builder__ptr.html">adiar::zdd_ptr</a> post_chain_root = builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> max_time = N*N-1;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> time = max_time; time &gt; t+1; time--) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> row = max_cell; row &gt;= 0; row--) {</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> col = max_cell; col &gt;= 0; col--) {</div>
<div class="line">        <span class="keywordflow">if</span> (!is_reachable(N, row, col)) { <span class="keywordflow">continue</span>; }</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> this_label = int_of_position(N, row, col, time);</div>
<div class="line">        post_chain_root = builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(this_label,</div>
<div class="line">                                           post_chain_root,</div>
<div class="line">                                           post_chain_root);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Time step t+1:</span></div>
<div class="line">  <span class="comment">//   Chain with each possible position reachable from some position at time &#39;t&#39;.</span></div>
<div class="line">  std::vector&lt;adiar::zdd_ptr&gt; to_chains(N*N, builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(<span class="keyword">false</span>));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> row = max_cell; row &gt;= 0; row--) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> col = max_cell; col &gt;= 0; col--) {</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> this_label = int_of_position(N, row, col, t+1);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> row_t = max_cell; row_t &gt;= 0; row_t--) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> col_t = max_cell; col_t &gt;= 0; col_t--) {</div>
<div class="line">          <span class="keywordflow">if</span> (!is_reachable(N, row_t, col_t)) { <span class="keywordflow">continue</span>; }</div>
<div class="line">          <span class="keywordflow">if</span> (!is_legal_move(N, row_t, col_t, row, col)) { <span class="keywordflow">continue</span>; }</div>
<div class="line"> </div>
<div class="line">          <span class="keyword">const</span> <span class="keywordtype">int</span> vector_idx = int_of_position(N, row_t, col_t);</div>
<div class="line"> </div>
<div class="line">          to_chains.at(vector_idx) = builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(this_label,</div>
<div class="line">                                                      to_chains.at(vector_idx),</div>
<div class="line">                                                      post_chain_root);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Time step t:</span></div>
<div class="line">  <span class="comment">//   For each position at time step &#39;t&#39;, check whether we are &quot;here&quot; and go to</span></div>
<div class="line">  <span class="comment">//   the chain checking &quot;where we go to&quot; at &#39;t+1&#39;.</span></div>
<div class="line">  <span class="keyword">typename</span> <a class="code" href="classadiar_1_1builder__ptr.html">adiar::zdd_ptr</a> root = builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(<span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> row = max_cell; row &gt;= 0; row--) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> col = max_cell; col &gt;= 0; col--) {</div>
<div class="line">      <span class="keywordflow">if</span> (!is_reachable(N, row, col)) { <span class="keywordflow">continue</span>; }</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> this_label = int_of_position(N, row, col, t);</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> to_chain_idx = int_of_position(N, row, col);</div>
<div class="line">      root = builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(this_label, root, to_chains.at(to_chain_idx));</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Time-step t&#39; &lt; t:</span></div>
<div class="line">  <span class="comment">//   Just allow everything, i.e. add no constraints</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> pos = int_of_position(N, max_cell, max_cell, t-1); pos &gt;= 0; pos--) {</div>
<div class="line">    root = builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(pos, root, root);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Finalize</span></div>
<div class="line">  <span class="keywordflow">return</span> builder.<a class="code" href="classadiar_1_1builder.html#ab01d6031368c51291ce565b03c049775">build</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
Hamiltonian Constraint</h2>
<p>Only using the above we would obtain <em>all</em> paths of length \( N^2 \); also the ones where a position is visited twice.</p>
<div class="fragment"><div class="line"><a class="code" href="classadiar_1_1zdd.html">adiar::zdd</a> constraint_exactly_once(<span class="keywordtype">int</span> N, <span class="keywordtype">int</span> r, <span class="keywordtype">int</span> c)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classadiar_1_1builder.html">adiar::zdd_builder</a> builder;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classadiar_1_1builder__ptr.html">adiar::zdd_ptr</a> out_never = builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(<span class="keyword">false</span>);</div>
<div class="line">  <a class="code" href="classadiar_1_1builder__ptr.html">adiar::zdd_ptr</a> out_once = builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> max_time = N*N-1;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> max_cell = N-1;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> this_t = max_time; this_t &gt;= 0; this_t--) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> this_r = max_cell; this_r &gt;= 0; this_r--) {</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> this_c = max_cell; this_c &gt;= 0; this_c--) {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> this_label = int_of_position(N, this_r, this_c, this_t);</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> is_rc = r == this_r &amp;&amp; c == this_c;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (!is_rc &amp;&amp; (this_t &gt; 0 || this_r &gt; r)) {</div>
<div class="line">          out_once = builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(this_label, out_once, out_once);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        out_never = builder.<a class="code" href="classadiar_1_1builder.html#ab6a82eebf191476fa81afd686c2888cd">add_node</a>(this_label,</div>
<div class="line">                                     out_never,</div>
<div class="line">                                     is_rc ? out_once : out_never);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Finalize</span></div>
<div class="line">  <span class="keywordflow">return</span> builder.<a class="code" href="classadiar_1_1builder.html#ab01d6031368c51291ce565b03c049775">build</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md12"></a>
Combining Constraints</h1>
<p>Notice, that each constraint above uses "don't care" nodes for everything that is not part of its problem domain. Furthermore, every time step is explicitly represented. So, the final set of solutions is the <em>intersection</em> (the <code>&amp;</code> operator) of all the above.</p>
<div class="fragment"><div class="line"><a class="code" href="classadiar_1_1zdd.html">adiar::zdd</a> combine_constraints(uint64_t N, <span class="keywordtype">bool</span> closed)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classadiar_1_1zdd.html">adiar::zdd</a> paths;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (N == 1) {</div>
<div class="line">    paths = <a class="code" href="group__module____zdd.html#gaf37f9772d2b1204255565d525a424808">adiar::zdd_ithvar</a>(0);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    paths = only_closed ? constraint_closed(N) : constraint_transition(N,0);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> t = 1; t &lt; N*N-1; t++) {</div>
<div class="line">      paths &amp;= constraint_transition(N,t);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; N; i++) {</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; N; j++) {</div>
<div class="line">        <span class="keywordflow">if</span> (only_closed &amp;&amp; is_closed_square(i,j)) { <span class="keywordflow">continue</span>; }</div>
<div class="line"> </div>
<div class="line">        paths &amp;= constraint_exactly_once(N,i,j);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">return</span> paths;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__module____zdd_html_gaf37f9772d2b1204255565d525a424808"><div class="ttname"><a href="group__module____zdd.html#gaf37f9772d2b1204255565d525a424808">adiar::zdd_ithvar</a></div><div class="ttdeci">zdd zdd_ithvar(zdd::label_t var)</div><div class="ttdoc">The family { {i} } .</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md13"></a>
Counting the Number of Paths</h1>
<p>Since every element of the final ZDD represents a unique path through the board, then the number of solutions is exactly the size of the set.</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> knights_tour(uint64_t N, <span class="keywordtype">bool</span> closed)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classadiar_1_1zdd.html">adiar::zdd</a> paths = combine_constraints(N, closed);</div>
<div class="line">  uint64_t solutions = <a class="code" href="group__module____zdd.html#ga514c85603336bd7600fcef19c0dc1785">adiar::zdd_size</a>(paths);</div>
<div class="line">  <span class="keywordflow">return</span> solutions;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__module____zdd_html_ga514c85603336bd7600fcef19c0dc1785"><div class="ttname"><a href="group__module____zdd.html#ga514c85603336bd7600fcef19c0dc1785">adiar::zdd_size</a></div><div class="ttdeci">uint64_t zdd_size(const zdd &amp;A)</div><div class="ttdoc">The number of sets in the family of sets.</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="page__examples.html">Examples</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
