#ifndef ADIAR_CUBE_H
#define ADIAR_CUBE_H

#include <stdint.h>

#include <adiar/map.h>
#include <adiar/file.h>

namespace adiar
{
  //////////////////////////////////////////////////////////////////////////////
  /// \brief Possible values for a set of variables; some are fixed to
  ///        \f$\bot\f$ (0), some to \f$\top\f$ (1), and a few others to *both*
  ///        values (2). This describes a hyperdimensional unit cube.
  //////////////////////////////////////////////////////////////////////////////
  class cube
  {
    /* ================================= TYPES ============================== */
  public:
    ////////////////////////////////////////////////////////////////////////////
    /// \brief Type of the variable label.
    ////////////////////////////////////////////////////////////////////////////
    using var_t = size_t;

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Possible values for each coordinate: 0, 1, and 2.
    ////////////////////////////////////////////////////////////////////////////
    enum class value_t : char {
      FALSE     = 0, // false
      TRUE      = 1, // true
      DONT_CARE = 2
    };

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Pair \f$(x,v)\f$ describing the possible values \f$v\f$ that
    ///        \f$x\f$ can be.
    ////////////////////////////////////////////////////////////////////////////
    using pair_t = map_pair<var_t, value_t>;

    /* ============================== VARIABLES ============================= */
  private:
    shared_file<pair_t> _file;

    friend class cube_stream;

    /* ============================= CONSTRUCTORS =========================== */
  public:
    ////////////////////////////////////////////////////////////////////////////
    cube()
    { }

    ////////////////////////////////////////////////////////////////////////////
    cube(const cube &o) : _file(o._file)
    { }

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Wraps a `shared_file<cube::pair_t>`.
    ///
    /// \remark The pairs in `f` should be provided in ascending order.
    ////////////////////////////////////////////////////////////////////////////
    cube(const shared_file<pair_t> &f) : _file(f)
    { }

    // TODO: decision diagram conversion-constructor?
    // TODO: iterator conversion-constructor?

    /* ================================ ACCESS ============================== */

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The number of variables.
    ////////////////////////////////////////////////////////////////////////////
    var_t vars() const;

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Whether the cube is empty.
    ///
    /// \details A cube is empty, if there exists no point inside of it.
    ////////////////////////////////////////////////////////////////////////////
    bool empty() const;

    ////////////////////////////////////////////////////////////////////////////
    /// \brief The number of dimensions of the cube.
    ///
    /// \details A variable that can be both 0 and 1 counts as a dimension. That
    ///          is, this counts the number of *non-fixed* variables.
    ////////////////////////////////////////////////////////////////////////////
    var_t dimensionality() const;

    /* ============================== OPERATORS ============================= */

    ////////////////////////////////////////////////////////////////////////////
    cube& operator=  (const cube &o) = default;

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Constructs the union of two cubes.
    ////////////////////////////////////////////////////////////////////////////
    cube  operator|  (const cube &o) const;

    ////////////////////////////////////////////////////////////////////////////
    /// \copydoc operator|
    ////////////////////////////////////////////////////////////////////////////
    cube& operator|= (const cube &o);

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Constructs the intersection of two cubes.
    ////////////////////////////////////////////////////////////////////////////
    cube  operator&  (const cube &o) const;

    ////////////////////////////////////////////////////////////////////////////
    /// \copydoc operator&
    ////////////////////////////////////////////////////////////////////////////
    cube& operator&= (const cube &o);
  };

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc cube::operator|
  //////////////////////////////////////////////////////////////////////////////
  cube cube_union(const cube &A, const cube &B);

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc cube::operator&
  //////////////////////////////////////////////////////////////////////////////
  cube cube_intsec(const cube &A, const cube &B);

  //////////////////////////////////////////////////////////////////////////////
  class cube_stream : public file_stream<cube::pair_t>
  {
  public:
    cube_stream() : file_stream<cube::pair_t>()
    { }

    cube_stream(const cube &c) : cube_stream()
    { attach(c); }

  public:
    void attach(const cube &c)
    { file_stream<cube::pair_t>::attach(c._file); }
  };
}

#endif // ADIAR_CUBE_H
