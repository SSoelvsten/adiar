#ifndef ADIAR_INTERNAL_DD_H
#define ADIAR_INTERNAL_DD_H

#include <variant>

#include <adiar/exec_policy.h>

#include <adiar/internal/cut.h>
#include <adiar/internal/data_types/arc.h>
#include <adiar/internal/data_types/node.h>
#include <adiar/internal/io/arc_file.h>
#include <adiar/internal/io/node_file.h>

namespace adiar::internal
{
  // TODO (MDD):
  // TODO (QMDD):
  // TODO (ADD (64-bit)):
  //   template both 'dd' and '__dd' with the node type (and derive the
  //   corresponding arc type).

  class dd;

  //////////////////////////////////////////////////////////////////////////////////////////////////
  /// A std::variant is used to distinguish the type of file. This uses std::monostate to hold a
  /// 'nothing' value, i.e. when there is no file.
  //////////////////////////////////////////////////////////////////////////////////////////////////
  using no_file = std::monostate;

  //////////////////////////////////////////////////////////////////////////////////////////////////
  /// \warning You should never explicitly be dealing with this class or have it be an l-value.
  /// Implicit conversion from an unreduced to the reduced type will call the correct reduce
  /// algorithm.
  ///
  /// An algorithm may return a node-based decision diagram in a `shared_levelized_file<node>` or a
  /// yet to-be reduced decision diagram in in an `shared_levelized_file<arc>`. So, we use a
  /// `std::variant` to hold the `shared_levelized_file<node>` or `shared_levelized_file<arc>`
  /// without having to pay for the expensive constructors and use a lot of space.
  ///
  /// A third possiblity is for it to contain a `std::monostate`, i.e. `no_file`, such that an
  /// algorithm can return 'null' in some specific places. In most cases, this should be ignored and
  /// will otherwise lead to exceptions.
  //////////////////////////////////////////////////////////////////////////////////////////////////
  class __dd
  {
  public:
    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Type of nodes of this diagram.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using node_type = node;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Type of the file object node-based representation of a diagram.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using shared_node_file_type = shared_levelized_file<node_type>;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Type of nodes of this diagram.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using arc_type = arc;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Type of the file object arc-based representation of a diagram.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using shared_arc_file_type = shared_levelized_file<arc_type>;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Union of levelized node or arc files to reflect the possible return types of a
    ///        function and a 'no_file' for 'error'.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    std::variant<no_file, shared_node_file_type, shared_arc_file_type> _union;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Propagation of the `dd.negate` flag.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    bool _negate = false;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Copy of the execution policy given to the top-down algorithm.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    exec_policy _policy;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // Constructors

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Default construction to \em nothing.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    __dd() = default;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Conversion for algorithms returning already-reduced nodes.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    __dd(const shared_node_file_type& f)
      : _union(f)
    {}

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Conversion for algorithms returning to-be reduced arcs
    ////////////////////////////////////////////////////////////////////////////////////////////////
    __dd(const shared_arc_file_type& f, const exec_policy& ep)
      : _union(f)
      , _policy(ep)
    {}

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Conversion from a decision diagram (such that it can be passed
    ///        along).
    ////////////////////////////////////////////////////////////////////////////////////////////////
    __dd(const dd& dd);

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // Accessors
    // TODO: change from 'file_t' to 'file::value_type'.

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Whether the union currently holds a certain file type.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename file_t>
    bool
    has() const
    {
      return std::holds_alternative<file_t>(_union);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Get the content of a certain type.
    ///
    /// \pre `has<file_t>() == true`
    ////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename file_t>
    const file_t&
    get() const
    {
      return std::get<file_t>(_union);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Whether it currently holds no content.
    ///
    /// \details The end user should not see this in the end.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    bool
    empty() const
    {
      return has<no_file>();
    }

    // TODO (optimisation):
    //   Add precondition to be with 'arcs' only?

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Number of nodes.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    size_t
    size() const
    {
      if (has<shared_arc_file_type>()) {
        // TODO (QMDD): Divide by node::outdegree instead of 2u
        return get<shared_arc_file_type>()->size() / 2u;
      }
      if (has<shared_node_file_type>()) { return get<shared_node_file_type>()->size(); }
      return 0u;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Obtain the 1-level cut of the desired type, i.e. of the sub-graph including the
    ///        desired type of arcs.
    ///
    /// \param ct The type of the cut to obtain
    ////////////////////////////////////////////////////////////////////////////////////////////////
    cut::size_type
    max_1level_cut(const cut ct) const
    {
      if (has<shared_arc_file_type>()) {
        const shared_arc_file_type& af = get<shared_arc_file_type>();
        return af->max_1level_cut + (ct.includes(false) ? af->number_of_terminals[false] : 0u)
          + (ct.includes(true) ? af->number_of_terminals[true] : 0u);
      }
      if (has<shared_node_file_type>()) { return get<shared_node_file_type>()->max_1level_cut[ct]; }
      return 0u;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Obtain the 2-level cut of the desired type, i.e. of the sub-graph including the
    ///        desired type of arcs.
    ///
    /// \param ct The type of the cut to obtain
    ////////////////////////////////////////////////////////////////////////////////////////////////
    cut::size_type
    max_2level_cut(const cut ct) const
    {
      if (has<shared_arc_file_type>()) {
        const shared_arc_file_type& af = get<shared_arc_file_type>();
        return std::min( // 3/2 times the 1-level cut
          (3 * af->max_1level_cut) / 2 + (ct.includes(false) ? af->number_of_terminals[false] : 0u)
            + (ct.includes(true) ? af->number_of_terminals[true] : 0u),
          // At most the number of nodes + 1
          (af->size() / 2u) + 1);
      }
      if (has<shared_node_file_type>()) { return get<shared_node_file_type>()->max_2level_cut[ct]; }
      return 0u;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Number of terminals of a certain value.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    size_t
    number_of_terminals(const bool value) const
    {
      if (has<shared_arc_file_type>()) {
        return get<shared_arc_file_type>()->number_of_terminals[this->_negate ^ value];
      }
      if (has<shared_node_file_type>()) {
        return get<shared_node_file_type>()->number_of_terminals[this->_negate ^ value];
      }
      return 0u;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Number of terminals.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    size_t
    number_of_terminals() const
    {
      if (has<shared_arc_file_type>()) {
        const shared_arc_file_type& af = get<shared_arc_file_type>();
        return af->number_of_terminals[false] + af->number_of_terminals[true];
      }
      if (has<shared_node_file_type>()) {
        const shared_node_file_type& nf = get<shared_node_file_type>();
        return nf->number_of_terminals[false] + nf->number_of_terminals[true];
      }
      return 0u;
    }
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Container for the files that represent a Decision Diagram.
  ///
  /// \remark To ensure the most disk-space is available, try to garbage collect objects of this
  ///         type as quickly as possible and/or minimise the number of lvalues of this type.
  //////////////////////////////////////////////////////////////////////////////////////////////////
  class dd
  {
    ////////////////////////////////////////////////////////////////////////////////////////////////
    // Constants
  public:
    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Type of nodes of this diagram.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using node_type = node;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Type of pointers of this diagram.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using pointer_type = node_type::pointer_type;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Type of this node's variable label.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using label_type = node_type::label_type;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief The maximal possible value for a unique identifier's label.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    static constexpr label_type max_label = node_type::max_label;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Type of this node's level identifier.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using id_type = node_type::id_type;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief The maximal possible value for this nodes level identifier.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    static constexpr id_type max_id = node_type::max_id;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Type of a terminal value.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using terminal_type = typename node_type::terminal_type;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief File type for the file object representing the diagram.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using node_file_type = levelized_file<node_type>;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief File type for the shared file object representing the diagram.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using shared_node_file_type = shared_file_ptr<node_file_type>;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // Internal state
  protected:
    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief The file describing the actual DAG of the decision diagram.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    shared_node_file_type _file;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Release the claim on the underlying file, thereby decreasing its reference counter.
    ///        If this is the sole owner of that file object, then that object is destructed
    ///        together with the physical files on disk (if temporary).
    ////////////////////////////////////////////////////////////////////////////////////////////////
    void
    deref()
    {
      this->_file.reset();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Whether to negate the leaves when reading nodes from the file.
    //
    // TODO: move to 'bdd' or generalize to 'attribute'?
    ////////////////////////////////////////////////////////////////////////////////////////////////
    bool _negate = false;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // Constructors
  public:
    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Constructor to wrap the node-based result of an algorithm.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    dd(const shared_node_file_type& f, bool negate = false)
      : _file(f)
      , _negate(negate)
    {}

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Copy construction, incrementing the reference count on the file
    ///        underneath.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    dd(const dd& dd)
      : _file(dd._file)
      , _negate(dd._negate)
    {}

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Move construction, taking over ownership of the files underneath.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    dd(dd&& dd)
      : _file(std::move(dd._file))
      , _negate(std::move(dd._negate))
    {}

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // NOTE:
    //
    //   To implement the specific DD, add the following move-conversion that runs the Reduce
    //   algorithm.
    //
    // dd(__dd &&dd)
    ////////////////////////////////////////////////////////////////////////////////////////////////

  public:
    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Read-only access to the negation flag.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    bool
    is_negated() const
    {
      return this->_negate;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Read-only access to the raw files and meta information.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    const shared_node_file_type
    file_ptr() const
    {
      return this->_file;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Read-only access to the members of the raw files and meta information, i.e. this is
    ///        similar to writing `.file_ptr()->`.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    const node_file_type*
    operator->() const
    {
      return this->_file.get();
    }

    /// \cond
    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Obtain the 1-level cut of the desired type, i.e. of the sub-graph including the
    ///        desired type of arcs.
    ///
    /// \param ct The type of the cut to obtain
    ////////////////////////////////////////////////////////////////////////////////////////////////
    cut::size_type
    max_1level_cut(const cut ct) const
    {
      return this->_file->max_1level_cut[negate_cut_type(ct)];
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Obtain the 2-level cut of the desired type, i.e. of the sub-graph including the
    ///        desired type of arcs.
    ///
    /// \param ct The type of the cut to obtain
    ////////////////////////////////////////////////////////////////////////////////////////////////
    cut::size_type
    max_2level_cut(const cut ct) const
    {
      return this->_file->max_2level_cut[negate_cut_type(ct)];
    }

    /// \endcond

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief The number of elements in the node file.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    size_t
    size() const
    {
      return this->_file->size();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief The number of nodes on the widest level.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    size_t
    width() const
    {
      return this->_file->width;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Number of terminals of a certain value.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    size_t
    number_of_terminals(const bool value) const
    {
      return this->_file->number_of_terminals[this->_negate ^ value];
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Number of terminals.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    size_t
    number_of_terminals() const
    {
      return this->number_of_terminals(false) + this->number_of_terminals(true);
    }

  private:
    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Obtain the cut-type that matches with the current state of the
    ///        negation flag.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    cut
    negate_cut_type(const cut ct) const
    {
      if (!this->_negate) { return ct; }

      switch (ct) {
      case cut::Internal_False: return cut::Internal_True;
      case cut::Internal_True: return cut::Internal_False;
      default: return ct;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // Friends
    // |- streaming classes
    friend class __dd;

    template <bool REVERSE>
    friend class level_info_stream;

    template <bool REVERSE>
    friend class node_stream;

    template <typename file_t, typename comp_t, size_t FILES, bool reverse>
    friend class level_merger;

    // |- algorithm functions and classes
    friend bool
    is_isomorphic(const exec_policy&, const dd&, const dd&);

    template <typename comp_policy>
    friend bool
    comparison_check(const exec_policy&, const dd&, const dd&);

    template <typename to_policy, typename from_policy>
    friend class convert_dd_policy;

    // |- public API
    template <typename dd_t>
    friend bool
    dd_isterminal(const dd_t& dd);

    template <typename dd_t>
    friend bool
    dd_valueof(const dd_t& dd);

    template <typename dd_t>
    friend label_type
    dd_minvar(const dd_t& dd);

    template <typename dd_t>
    friend label_type
    dd_maxvar(const dd_t& dd);
  };

  inline __dd::__dd(const dd& dd)
    : _union(dd._file)
    , _negate(dd._negate)
  {}

  /// \cond
  template <typename DD, typename __DD>
  class dd_policy
  {
    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// Constants
  public:
    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Type of the class representing the \em reduced decision diagram.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using dd_type = DD;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Type of the class representing the \em possibly \em unreduced decision diagram.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using __dd_type = __DD;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Type of nodes of this diagram.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using node_type = typename dd_type::node_type;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Type of pointers of this diagram.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using pointer_type = typename dd_type::pointer_type;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Type of pointers of this diagram.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using children_type = typename node_type::children_type;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Type of this node's variable label.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using label_type = typename dd_type::label_type;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief The maximal possible value for a unique identifier's label.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    static constexpr label_type max_label = dd_type::max_label;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Type of this node's level identifier.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using id_type = typename dd_type::id_type;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief The maximal possible value for this nodes level identifier.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    static constexpr id_type max_id = dd_type::max_id;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Type of a terminal value.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using terminal_type = typename dd_type::terminal_type;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Type of shared nodes for this diagram type.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using shared_node_file_type = typename __dd_type::shared_node_file_type;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Type of shared arcs for this diagram type.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using shared_arc_file_type = typename __dd_type::shared_arc_file_type;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// Function declaration
  public:
    //////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Result of applying the suppression rule.
    ///
    /// \returns A pointer to the node itself or one of its children.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    static inline pointer_type
    reduction_rule(const node_type& n);

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Provides the children of a node that was suppressed.
    ///
    /// \details This is the inverse of `reduction_rule`; to fully reconstruct the node, add the
    ///          variable label next to these children.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    static inline children_type
    reduction_rule_inv(const pointer_type& child);
  };

  /// \endcond
}

#endif // ADIAR_INTERNAL_DD_H
