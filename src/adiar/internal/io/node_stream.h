#ifndef ADIAR_INTERNAL_IO_NODE_STREAM_H
#define ADIAR_INTERNAL_IO_NODE_STREAM_H

#include <adiar/internal/data_types/node.h>
#include <adiar/internal/dd.h>
#include <adiar/internal/io/levelized_file.h>
#include <adiar/internal/io/levelized_file_stream.h>

namespace adiar::internal
{
  //////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief         Stream of nodes from a node file.
  ///
  /// \param Reverse Whether the reading direction should be Reversed (relatively to the ordering of
  ///                nodes within the file).
  ///
  /// \see shared_levelized_file<node>
  //
  // TODO: Move '!' negation out of 'file_stream', 'levelized_file_stream', and instead in here!
  //////////////////////////////////////////////////////////////////////////////////////////////////
  template <bool Reverse = false>
  class node_stream : public levelized_file_stream<node, !Reverse>
  {
    using parent_type = levelized_file_stream<node, !Reverse>;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Whether nodes should be \em negated on-the-fly.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    bool _negate = false;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Number of levels with which an element ought to be shifted.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    node::signed_label_type _shift = 0;

  public:
    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Create unattached to any file.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    node_stream() = default;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    node_stream(const node_stream<Reverse>&) = delete;
    node_stream(node_stream<Reverse>&&)      = delete;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Create attached to a node file.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    node_stream(const levelized_file<node>& file,
                bool negate                   = false,
                node::signed_label_type shift = 0)
      : parent_type(file)
      , _negate(negate)
      , _shift(shift)
    {}

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Create attached to a shared node file.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    node_stream(const shared_ptr<levelized_file<node>>& file,
                bool negate                   = false,
                node::signed_label_type shift = 0)
      : parent_type(file)
      , _negate(negate)
      , _shift(shift)
    {}

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Create attached to a Decision Diagram.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    node_stream(const dd& diagram)
      : parent_type(diagram.file_ptr())
      , _negate(diagram.is_negated())
      , _shift(0 /*TODO*/)
    {}

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Whether the stream contains more elements.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    bool
    can_pull() const
    {
      return parent_type::template can_pull<0>();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Obtain next element (and move the read head).
    ///
    /// \pre `can_pull() == true`.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    const node
    pull()
    {
      return shift_replace(cnot(parent_type::template pull<0>(), this->_negate), this->_shift);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Obtain the next element (but do not move the read head).
    ///
    /// \pre `can_pull() == true`.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    const node
    peek()
    {
      return shift_replace(cnot(parent_type::template peek<0>(), this->_negate), this->_shift);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief   Obtain the first node "greater than" or "equal" the seeked uid.
    ///
    /// \param u Unique Identifier to seek for.
    ///
    /// \pre     `can_pull() == true`.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    const node
    seek(const node::uid_type& u)
    {
      const node::uid_type u_unshifted = shift_replace(u.as_ptr(), -this->_shift);
      const node n_raw                 = parent_type::_streams[0].seek(std::move(u_unshifted));
      return shift_replace(cnot(std::move(n_raw), this->_negate), this->_shift);
    }
  };
}

#endif // ADIAR_INTERNAL_IO_NODE_STREAM_H
