#ifndef ADIAR_FILE_STREAM_H
#define ADIAR_FILE_STREAM_H

#include <tpie/tpie.h>
#include <tpie/sort.h>

#include <adiar/internal/memory.h>
#include <adiar/internal/io/file.h>

namespace adiar::internal
{
  //////////////////////////////////////////////////////////////////////////////
  /// \brief Stream to a file with a one-way reading direction.
  ///
  /// \param elem_type   The type of the file's elements
  ///
  /// \param REVERSE     Whether the reading direction should be reversed
  ///
  /// \param file_t      The type of the shared pointer to a file
  //////////////////////////////////////////////////////////////////////////////
  template <typename elem_type, bool REVERSE = false>
  class file_stream
  {
  public:
    ////////////////////////////////////////////////////////////////////////////
    /// \brief Type of the file's elements.
    ////////////////////////////////////////////////////////////////////////////
    typedef elem_type elem_t;

  public:
    ////////////////////////////////////////////////////////////////////////////
    static size_t memory_usage()
    {
      return tpie::file_stream<elem_t>::memory_usage();
    }

  private:
    ////////////////////////////////////////////////////////////////////////////
    /// \brief Buffer of a single element, since TPIE does not support a
    ///        `peek_back` function yet (TPIE Issue #187).
    ////////////////////////////////////////////////////////////////////////////
    mutable elem_t _peeked;

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Whether an \em unpulled element is stored in `_peeked`.
    ////////////////////////////////////////////////////////////////////////////
    mutable bool _has_peeked = false;

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Whether elements should be \em negated on-the-fly.
    ////////////////////////////////////////////////////////////////////////////
    bool _negate = false;

    ////////////////////////////////////////////////////////////////////////////
    /// \brief TPIE's file stream object to read the file with.
    ////////////////////////////////////////////////////////////////////////////
    mutable typename tpie::file_stream<elem_t> _stream;

    ////////////////////////////////////////////////////////////////////////////
    /// \brief If attached to a shared file then hook into the reference
    ///        counting such that the file is not garbage collected while we
    ///        read from it.
    ////////////////////////////////////////////////////////////////////////////
    shared_ptr<void> _file_ptr;

  public:
    ////////////////////////////////////////////////////////////////////////////
    /// \brief Construct unattached to any file.
    ////////////////////////////////////////////////////////////////////////////
    file_stream() { }

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Construct attached to a given shared `file<elem_t>`.
    ////////////////////////////////////////////////////////////////////////////
    file_stream(const file<elem_t> &f,
                bool negate = false)
    { attach(f, negate); }

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Construct attached to a given shared `file<elem_t>`.
    ////////////////////////////////////////////////////////////////////////////
    file_stream(const adiar::shared_ptr<file<elem_t>> &f,
                bool negate = false)
    { attach(f, negate); }

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Detaches and cleans up when destructed.
    ////////////////////////////////////////////////////////////////////////////
    ~file_stream()
    { detach(); }

  protected:
    ////////////////////////////////////////////////////////////////////////////
    void attach(const file<elem_t> &f,
                const adiar::shared_ptr<void> &shared_ptr,
                bool negate)
    {
      // Detach from prior file, if any.
      if (attached()) { detach(); }

      // Hook into reference counting.
      _file_ptr = shared_ptr;

      // Touch the file to make sure it exists on disk. Since 'f' is const, use
      // the private '__touch()' member function instead.
      f.__touch();

      // Open the stream to the file
      _stream.open(f._tpie_file, file<elem_t>::read_access);
      reset();

      // Store negation flag.
      _negate = negate;
    }

    ////////////////////////////////////////////////////////////////////////////
    // Befriend the few places that need direct access to the above 'attach'.
    template <typename tparam__elem_t, bool tparam__REVERSE>
    friend class levelized_file_stream;

  public:
    ////////////////////////////////////////////////////////////////////////////
    /// \brief Attach to a file.
    ///
    /// \pre No `file_writer` is currently attached to this file.
    ////////////////////////////////////////////////////////////////////////////
    void attach(const file<elem_t> &f,
                bool negate = false)
    {
      attach(f, nullptr, negate);
    }

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Attach to a shared file.
    ///
    /// \pre No `file_writer` is currently attached to this file.
    ////////////////////////////////////////////////////////////////////////////
    void attach(const adiar::shared_ptr<file<elem_t>> &f,
                bool negate = false)
    {
      attach(*f, f, negate);
    }

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Whether the reader is currently attached.
    ////////////////////////////////////////////////////////////////////////////
    bool attached() const
    {
      return _stream.is_open();
    }

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Detach from the file, i.e. close the stream.
    ////////////////////////////////////////////////////////////////////////////
    void detach()
    {
      _stream.close();
      if (_file_ptr) { _file_ptr.reset(); }
    }

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Reset the read head back to the beginning (relatively to the
    ///        reading direction).
    ////////////////////////////////////////////////////////////////////////////
    void reset()
    {
      if constexpr (REVERSE) {
        _stream.seek(0, tpie::file_stream_base::end);
      } else {
        _stream.seek(0);
      }
    }

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Whether the stream contains more elements.
    ////////////////////////////////////////////////////////////////////////////
    bool can_pull() const
    {
      return _has_peeked
        || (REVERSE ? _stream.can_read_back() : _stream.can_read());
    }

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Obtain the next element (and move the read head).
    ///
    /// \pre `can_pull() == true`.
    ////////////////////////////////////////////////////////////////////////////
    const elem_t pull()
    {
      if (_has_peeked) {
        _has_peeked = false;
        return _peeked;
      }
      const elem_t t = REVERSE ? _stream.read_back() : _stream.read();
      return _negate ? !t : t;
    }

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Obtain the next element (but do not move the read head)
    ///
    /// \pre `can_pull() == true`.
    ////////////////////////////////////////////////////////////////////////////
    const elem_t peek()
    {
      if (!_has_peeked) {
        _peeked = pull();
        _has_peeked = true;
      }
      return _peeked;
    }
  };
}

#endif // ADIAR_FILE_STREAM_H
