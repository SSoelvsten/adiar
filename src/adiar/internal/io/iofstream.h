#ifndef ADIAR_INTERNAL_IO_IOFSTREAM_H
#define ADIAR_INTERNAL_IO_IOFSTREAM_H

#include <tpie/file_stream.h>

#include <adiar/internal/assert.h>
#include <adiar/internal/io/file.h>

namespace adiar::internal
{
  //////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Stream to a file with a bidirectional read and write direction.
  //////////////////////////////////////////////////////////////////////////////////////////////////
  template <typename T>
  class iofstream
  {
  public:
    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Type of the file's elements.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    using value_type = T;

  public:
    ////////////////////////////////////////////////////////////////////////////////////////////////
    static size_t
      memory_usage()
    {
      return tpie::file_stream<value_type>::memory_usage();
    }

  private:
    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief If attached to a shared file, then hook into the reference counting such that the
    ///        file is not garbage collected while we read from and/or write to it.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    shared_ptr<void> _file_ptr;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief TPIE's file stream object to read/write the file with.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    mutable typename tpie::file_stream<value_type> _stream;

  public:
    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Construct unattached to any file.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    iofstream()
    {}

    ////////////////////////////////////////////////////////////////////////////////////////////////
    iofstream(const iofstream<value_type>&) = delete;
    iofstream(iofstream<value_type>&&)      = delete;

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Construct attached to a given shared `file<value_type>`.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    iofstream(const file<value_type>& f)
    {
      attach(f);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Construct attached to a given shared `file<value_type>`.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    iofstream(const adiar::shared_ptr<file<value_type>>& f)
    {
      attach(f);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Detaches and cleans up when destructed.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    ~iofstream()
    {
      detach();
    }

  protected:
    ////////////////////////////////////////////////////////////////////////////////////////////////
    void
    attach(const file<value_type>& f, const adiar::shared_ptr<void>& shared_ptr)
    {
      // Detach from prior file, if any.
      if (this->attached()) { this->detach(); }

      // Hook into reference counting.
      this->_file_ptr = shared_ptr;

      // Open the stream to the file
      this->_stream.open(f._tpie_file, file<value_type>::rw_access);
    }

  public:
    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Attach to an unnamed temporary file.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    void
    attach()
    {
      this->_stream.open();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Attach to a file.
    ///
    /// \pre No other `iofstream` or `ofstream` is currently attached to this file.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    void
    attach(const file<value_type>& f)
    {
      this->attach(f, nullptr);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Attach to a shared file.
    ///
    /// \pre No other `iofstream` or `ofstream` is currently attached to this file.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    void
    attach(const adiar::shared_ptr<file<value_type>>& f)
    {
      this->attach(*f, f);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Whether the reader is currently attached.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    bool
    attached() const
    {
      return this->_stream.is_open();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Detach from the file, i.e. close the stream.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    void
    detach()
    {
      this->_stream.close();
      if (this->_file_ptr) { this->_file_ptr.reset(); }
    }

  public:
    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Seek to a given offset (index).
    ///
    /// \pre `attached() == true`.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    void seek(size_t offset)
    {
      this->_stream.seek(offset);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Seek to the beginning of the stream.
    ///
    /// \pre `attached() == true`.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    void seek_begin()
    {
      this->_stream.seek(0);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Seek to the end of the stream.
    ///
    /// \pre `attached() == true`.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    void seek_end()
    {
      this->_stream.seek(0, tpie::file_stream_base::end);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    size_t offset() const
    {
      return this->_stream.offset();
    }

    size_t size() const
    {
      return this->_stream.size();
    }

  public:
    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Whether there is a next element to retrieve.
    ///
    /// \pre `attached() == true`.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    bool has_next() const
    {
      return _stream.can_read();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Obtain the next element.
    ///
    /// \pre `attached() == true`.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    const value_type& next()
    {
      return _stream.read();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Whether there is a next element to retrieve.
    ///
    /// \pre `attached() == true`.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    bool has_prev() const
    {
      return _stream.can_read_back();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Obtain the previous element.
    ///
    /// \pre `attached() == true`.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    const value_type& prev()
    {
      return _stream.read_back();
    }

  public:
    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Write to the current offset and move read-head to the next position.
    ///
    /// \pre `attached() == true`.
    ////////////////////////////////////////////////////////////////////////////////////////////////
    void write(const value_type &v)
    {
      this->_stream.write(v);
    }
  };
}

#endif // ADIAR_INTERNAL_IO_IOFSTREAM_H
