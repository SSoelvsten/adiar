#ifndef ADIAR_INTERNAL_IO_SHARED_FILE_H
#define ADIAR_INTERNAL_IO_SHARED_FILE_H

#include <adiar/internal/memory.h>

namespace adiar::internal
{
  // TODO: switch to derive `file_t` from `elem_t`.
  //////////////////////////////////////////////////////////////////////////////
  /// \brief Provides compile-time known settings and meta information variables
  ///        used in `shared_file<elem_type>`.
  //////////////////////////////////////////////////////////////////////////////
  //template <typename elem_type>
  //struct SHARED_FILE_CONSTANTS
  //{ };

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Provides shared ownership of a single file. This also includes
  ///        (thread-safe) reference counting and automatic garbage collection.
  ///
  /// \details This is a wrapper on the `adiar::shared_ptr` (which in itself is
  ///          just a wrapper on `std::shared_ptr`) to slightly change its
  ///          semantics:
  ///          - Default constructor creates a new fresh file rather than being
  ///            null (TODO: change?)
  ///          - If `const` then not only can the pointer not be moved, but the
  ///            file underneath cannot be changed either.
  ///
  /// \param file_type The type of the underlying file
  //////////////////////////////////////////////////////////////////////////////
  template <typename file_type>
  class shared_file : public shared_ptr<file_type>
  {
  public:
    ////////////////////////////////////////////////////////////////////////////
    /// \brief Type of the file object.
    ////////////////////////////////////////////////////////////////////////////
    typedef file_type file_t;

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Type of the file's elements.
    ////////////////////////////////////////////////////////////////////////////
    typedef typename file_t::elem_t elem_t;

  public:
    ////////////////////////////////////////////////////////////////////////////
    /// \brief Default constructor with a new fresh temporary file.
    ////////////////////////////////////////////////////////////////////////////
    shared_file() : shared_ptr<file_t>(adiar::make_shared<file_t>())
    { }

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Conversion-constructor from raw `shared_ptr<file_t>`.
    ////////////////////////////////////////////////////////////////////////////
    shared_file(const shared_ptr<file_t> &other) : shared_ptr<file_t>(other)
    { }

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Copy-constructor.
    ////////////////////////////////////////////////////////////////////////////
    shared_file(const shared_file<file_t> &other) = default;

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Move-constructor.
    ////////////////////////////////////////////////////////////////////////////
    shared_file(shared_file<file_t> &&other) = default;

  public:
    ////////////////////////////////////////////////////////////////////////////
    shared_file<file_t>& operator= (const shared_file<file_t> &o) = default;

    ////////////////////////////////////////////////////////////////////////////
    shared_file<file_t>& operator= (shared_file<file_t> &&o) = default;

  public:
    ////////////////////////////////////////////////////////////////////////////
    /// \brief Obtain the raw pointer (read-only).
    ////////////////////////////////////////////////////////////////////////////
    const file_t* get() const
    { return shared_ptr<file_t>::get(); }

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Obtain the raw pointer.
    ////////////////////////////////////////////////////////////////////////////
    file_t* get()
    { return shared_ptr<file_t>::get(); }

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Dereference the pointer to obtain the file (read-only).
    ////////////////////////////////////////////////////////////////////////////
    const file_t& operator*() const
    { return *get(); }

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Dereference the pointer to obtain the file.
    ////////////////////////////////////////////////////////////////////////////
    file_t& operator*()
    { return *get(); }

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Member access (read-only) to the file.
    ////////////////////////////////////////////////////////////////////////////
    const file_t* operator->() const
    { return get(); }

    ////////////////////////////////////////////////////////////////////////////
    /// \brief Member access for the underlying file.
    ////////////////////////////////////////////////////////////////////////////
    file_t* operator->()
    { return get(); }
  };

  ////////////////////////////////////////////////////////////////////////////
  /// The <tt>file</tt> and <tt>__levelized_file</tt> classes are hidden behind a
  /// shared pointer, such that we can parse it around. That is, all actual
  /// files we are going to deal with are a <tt>shared_file<x_file<T>></tt>.
  ///
  /// \param T Type of the file's content
  ///
  /// TODO: remove...
  ////////////////////////////////////////////////////////////////////////////
  template<typename elem_type>
  using simple_file = shared_file<file<elem_type>>;
}

#endif // ADIAR_INTERNAL_IO_SHARED_FILE_H
